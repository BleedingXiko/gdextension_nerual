[gd_scene load_steps=6 format=3 uid="uid://bkfbffasse6kf"]

[ext_resource type="Script" path="res://Demo/NN/demo.gd" id="1_2s4nr"]
[ext_resource type="Script" path="res://Demo/NN/won.gd" id="4_v6yp1"]
[ext_resource type="PackedScene" uid="uid://dqh5ftagl7t68" path="res://Demo/NN/player.tscn" id="6_qs1wj"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_mgyl3"]
size = Vector2(35.5, 223)

[sub_resource type="GDScript" id="GDScript_m2fi2"]
script/source = "extends Node2D

var ACTIVATIONS = Activation.new().functions


@export var AI_Scene: PackedScene

@export var Batch_Size: int = 50

@export var Generation_Delay: int = 10

@export var show_only_best: bool = false
@export var save_best: bool = true
@export var save_path: String = \"./nn.data\"

signal gen_changed(_generation: int)
signal true_batch_size(_size: int)

var setting_up: bool = true
var freeing: bool = false

@export_range(1, 80) var input_nodes: int = 1
@export_range(1, 80) var hidden_nodes: int = 1
@export_range(1, 80) var output_nodes: int = 1
@export_enum(\"SOFTPLUS\", \"ELU\", \"PRELU\", \"ARCTAN\", \"TANH\", \"RELU\", \"SIGMOID\") var hidden_activation: String = \"RELU\"
@export_enum(\"SOFTPLUS\", \"ELU\", \"PRELU\", \"ARCTAN\", \"TANH\", \"RELU\", \"SIGMOID\") var output_activation: String = \"SIGMOID\"

@export_range(1, 80) var random_population: int = 20

@export var use_reproduction: bool = false

@export_range(1, 80) var reproduced_population: int = 5

var top_value_cutoff

var generation: int = 0

var best_nn: NeuralNetwork
var spawn_population: Array = []
var current_generation_freed: int = 0

var first_gen_spawn_size
var timer: Timer = Timer.new()


var prev_best = null

var best_10_nn: Array[NeuralNetwork]

func _ready():
	assert(ceil(Batch_Size / 2) <= reproduced_population, \"reproduced_population must be set higher or equal to the Half of the Batch Size as some weird bug arises!\")
	top_value_cutoff = reproduced_population * 2
	first_gen_spawn_size = Batch_Size + 1 + random_population
	if use_reproduction:
		assert(Batch_Size >= 10, \"Batch Size can not go below or be 10 as some weird bug arises!\")
		first_gen_spawn_size += reproduced_population
	top_value_cutoff += 1
	add_child(timer)
	child_exiting_tree.connect(Callable(self, \"on_ai_exit_tree\"))
	timer.wait_time = Generation_Delay
	timer.timeout.connect(Callable(self, \"reload_generation\"))
	

	best_nn = NeuralNetwork.new(input_nodes, hidden_nodes, output_nodes)
	best_nn.set_activation_function(ACTIVATIONS[hidden_activation], ACTIVATIONS[output_activation])
	
	spawn()

func spawn_loaded():
	var loaded_net = NeuralNetwork.load(save_path)
	var new_ai = AI_Scene.instantiate()
	new_ai.nn = NeuralNetwork.copy(loaded_net)
	call_deferred(\"add_child\", new_ai)

func spawn():
	gen_changed.emit(generation)
	print(\"Generation: \", generation)
	spawn_population = []

	
	if generation == 0:
		for i in range(first_gen_spawn_size):
			randomize()
			var new_ai = AI_Scene.instantiate()
			new_ai.nn = NeuralNetwork.new(input_nodes, hidden_nodes, output_nodes)
			new_ai.nn.set_activation_function(ACTIVATIONS[hidden_activation], ACTIVATIONS[output_activation])
			spawn_population.append(new_ai)
	else:
		for i in range(Batch_Size):
			var new_ai = AI_Scene.instantiate()
			new_ai.nn =  NeuralNetwork.copy(NeuralNetwork.mutate(best_nn))
			new_ai.nn.set_activation_function(ACTIVATIONS[hidden_activation], ACTIVATIONS[output_activation])
			spawn_population.append(new_ai)
		
		for i in range(random_population):
			randomize()
			var new_ai = AI_Scene.instantiate()
			new_ai.nn = NeuralNetwork.new(input_nodes, hidden_nodes, output_nodes)
			new_ai.nn.set_activation_function(ACTIVATIONS[hidden_activation], ACTIVATIONS[output_activation])
			spawn_population.append(new_ai)
			
		var new_ai = AI_Scene.instantiate()
		new_ai.nn = NeuralNetwork.copy(best_nn)
		new_ai.nn.set_activation_function(ACTIVATIONS[hidden_activation], ACTIVATIONS[output_activation])
		spawn_population.append(new_ai)
	
		if use_reproduction:
			var first_array: Array[NeuralNetwork]
			var second_array: Array[NeuralNetwork]
			
			randomize()
			for i in range(best_10_nn.size()):
				var random_choice = randi_range(0, best_10_nn.size() - 1)
				if i % 2 == 0:
					first_array.append(best_10_nn[random_choice])
				else:
					second_array.append(best_10_nn[random_choice])
				best_10_nn.remove_at(random_choice)
			
			for i in range(first_array.size()):
				if first_array.size() == second_array.size():
					var _new_ai = AI_Scene.instantiate()
					_new_ai.nn =  NeuralNetwork.copy(NeuralNetwork.mutate(NeuralNetwork.reproduce(first_array[i], second_array[i])))
					spawn_population.append(_new_ai)
				else:
					for i2 in range(reproduced_population):
						randomize()
						var _new_ai = AI_Scene.instantiate()
						_new_ai.nn = NeuralNetwork.new(input_nodes, hidden_nodes, output_nodes)
						new_ai.nn.set_activation_function(ACTIVATIONS[hidden_activation], ACTIVATIONS[output_activation])
						spawn_population.append(_new_ai)
	setting_up = true
	for ai in spawn_population:
		call_deferred(\"add_child\", ai)
		if show_only_best: ai.modulate = Color(0, 0, 0, 0)
	setting_up = false
	timer.start(Generation_Delay)
	true_batch_size.emit(spawn_population.size())
	generation += 1
	best_10_nn = []


func _process(_delta):
	if !show_only_best or setting_up: return
	spawn_population.sort_custom(Callable(self, \"custom_sort_visiblity\"))

	if prev_best != null and spawn_population[-1] != prev_best: prev_best.modulate = Color.TRANSPARENT
	spawn_population[-1].modulate = spawn_population[-1].nn.color
	prev_best = spawn_population[-1]

func on_ai_exit_tree(node: Node):
	if node is Timer: return
	if use_reproduction: best_10_nn.append(NeuralNetwork.copy(node.nn))
	if node.nn.fitness > best_nn.fitness:
		best_nn = NeuralNetwork.copy(node.nn)
		print(node.nn.get_reference_count())
	spawn_population.erase(node)
	if freeing: return
	current_generation_freed += 1
	if current_generation_freed == Batch_Size:
		reload_generation()

func reload_generation():
	best_10_nn.sort_custom(Callable(self, \"custom_sort\"))
	if use_reproduction: best_10_nn = best_10_nn.slice(best_10_nn.size() - top_value_cutoff, -1)
	
	if save_best and !best_10_nn.is_empty():
		best_10_nn[-1].save(save_path)
	freeing = true
	timer.stop()
	
	for i in get_children():
		if !(i is Timer): i.queue_free()
	
	spawn()
	freeing = false

func custom_sort(a, b):
	return a.fitness < b.fitness

func custom_sort_visiblity(a, b):
	return a.nn.fitness < b.nn.fitness
"

[node name="Demo" type="Node2D" groups=["demo"]]
script = ExtResource("1_2s4nr")

[node name="won" type="Area2D" parent="."]
position = Vector2(1172, 365)
collision_mask = 2
script = ExtResource("4_v6yp1")

[node name="CollisionShape2d" type="CollisionShape2D" parent="won"]
modulate = Color(1, 0, 0.498039, 1)
shape = SubResource("RectangleShape2D_mgyl3")

[node name="Neural_Net" type="Node2D" parent="."]
position = Vector2(43, 454)
script = SubResource("GDScript_m2fi2")
AI_Scene = ExtResource("6_qs1wj")
Batch_Size = 20
Generation_Delay = 8
save_best = false
input_nodes = 9
hidden_nodes = 4
output_nodes = 2
random_population = 6
use_reproduction = true
reproduced_population = 15

[node name="gen" type="RichTextLabel" parent="."]
offset_right = 896.0
offset_bottom = 192.0
theme_override_font_sizes/normal_font_size = 75

[node name="Camera2d" type="Camera2D" parent="."]
position = Vector2(720, 384)
zoom = Vector2(0.8, 0.85)

[connection signal="tree_exiting" from="." to="." method="_on_demo_tree_exiting"]
[connection signal="body_entered" from="won" to="won" method="_on_won_body_entered"]
